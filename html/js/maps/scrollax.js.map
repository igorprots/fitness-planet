{"version":3,"sources":["scrollax.js"],"names":["factory","define","amd","exports","module","require","jQuery","ArrayProto","Array","prototype","ObjProto","Object","push","hasOwnProperty","splice","numberRegExp","namespace","transforms","window","$doc","$","document","body","transform","gpuAcceleration","position","bind","unbind","Scrollax","frame","options","callbackMap","self","this","$frame","eq","$win","prevent","each","instance","i","instances","tmpArray","l","$freezer","timer","containsPerformanceClass","offset","isHorizontal","parentOffset","pos","parent","parentOptions","ratio","start","end","parallaxElements","parallaxable","properties","property","value","transformStyle","numbers","o","extend","defaults","parents","$parents","parentSelector","lownamespace","elementsSelector","callbacks","resizeID","isWindow","pl","load","performanceTrick","element","$parent","frameIsWindow","getInlineOptions","trigger","reload","pI","pElement","parallaxElement","call","scroll","scrollHandler","getIndex","is_numeric","inArray","length","index","one","name","fn","on","apply","arguments","off","proxy","_typeof","key","names","split","n","nl","callbackIndex","f","fl","set","isPlainObject","destroy","resizeHandler","initialized","init","find","horizontal","parentEachHandler","setTimeout","clearTimeout","addClass","removeClass","getOffset","parallax","styleHandler","el","translateX","translateY","match","replace","parseFloat","style","within","arg1","k","doc","docEl","win","winTop","winLeft","box","relBox","fnid","detachEvent","warn","message","console","isWin","width","innerWidth","documentElement","clientWidth","offsetWidth","height","innerHeight","clientHeight","offsetHeight","isNaN","number","min","max","$element","data","toLowerCase","eval","val","docWin","alert","defaultView","parentWindow","preventDefault","relativeTo","stopPropagation","cancelBubble","testProp","prop","p","prefixes","charAt","toUpperCase","slice","err","prefixedProp","undefined","ownerDocument","pageYOffset","scrollTop","clientTop","pageXOffset","scrollLeft","clientLeft","top","left","getBoundingClientRect","a","b","right","bottom","addEventListener","type","capture","event","target","srcElement","attachEvent","removeEventListener","createElement","methodArgs","method","plugin","css","head","getElementsByTagName","styleSheet","appendChild","createTextNode"],"mappings":"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","file":"../scrollax.js","sourcesContent":["/**\n *  _______ _______  ______  _____                _______ _     _\n *  |______ |       |_____/ |     | |      |      |_____|  \\___/\n *  ______| |_____  |    \\_ |_____| |_____ |_____ |     | _/   \\_\n *\n *  Parallax Scrolling Library\n *  http://iprodev.github.io/Scrollax.js\n *\n *  @version:  1.0.0\n *  @released: July 21, 2015\n *\n *  @author:   iProDev (Hemn Chawroka)\n *             http://iprodev.com/\n *\n *  Licensed under the MIT license.\n *  http://opensource.org/licenses/MIT\n *\n */\n(function(factory) {\n    'use strict';\n    if (typeof define === 'function' && define.amd) {\n        // AMD\n        define(['jquery'], factory);\n    } else if (typeof exports !== 'undefined') {\n        // CommonJS\n        module.exports = factory(require('jquery'));\n    } else {\n        // Global\n        factory(jQuery);\n    }\n}(function($) {\n    'use strict';\n\n    /**\n     * References.\n     */\n    var ArrayProto = Array.prototype,\n        ObjProto = Object.prototype,\n\n        // Create quick reference variables for speed access to core prototypes.\n        push = ArrayProto.push,\n        splice = ArrayProto.splice,\n        hasOwnProperty = ObjProto.hasOwnProperty,\n\n        // Global variables\n        namespace = 'Scrollax',\n        lownamespace = namespace.toLowerCase(),\n        numberRegExp = /[-+]?\\d+(\\.\\d+)?/g,\n        transforms = ['translateX', 'translateY', 'rotate', 'rotateX', 'rotateY', 'rotateZ', 'skewX', 'skewY', 'scaleX', 'scaleY'],\n\n        // Global DOM References\n        $win = $(window),\n        $doc = $(document.body),\n\n        // Support indicators\n        transform, gpuAcceleration,\n\n        // Speed access to frequently called functions\n        position, bind, unbind;\n\n    /**\n     * Scrollax\n     *\n     * @class\n     *\n     * @param {Element}  frame  Scrolling frame.\n     */\n    var Scrollax = function(frame, options, callbackMap) {\n        // Private variables\n        var self = this;\n        var $frame = frame && $(frame).eq(0) || $win;\n        var instances = Scrollax.instances;\n        var prevent = null;\n\n        frame = $frame[0];\n\n        // Check the contest existance\n        $.each(instances, function(instance, i) {\n            if (instance && instance.frame === frame) {\n                prevent = true;\n            }\n        });\n\n        // Send warn message to browser when the Frame is not available or initialized before\n        if (!frame || prevent) {\n            if (prevent) {\n                warn(namespace + ': Scrollax has been initialized for this frame!');\n            } else {\n                warn(namespace + ': Frame is not available!');\n            }\n            return;\n        }\n\n        // Merge options\n        var o = $.extend({}, Scrollax.defaults, options);\n\n        var parents = [],\n            $parents = null,\n            parentSelector = o.parentSelector || '[data-' + lownamespace + '-parent]',\n            elementsSelector = o.elementsSelector || '[data-' + lownamespace + ']',\n            callbacks = {},\n            tmpArray = [],\n            resizeID,\n            frameIsWindow = isWindow(frame),\n\n            // Garbage collecting purposes\n            i, l, pi, pl, $freezer, timer, containsPerformanceClass, offset, isHorizontal, parentOffset, pos, parent, parentOptions, ratio, start, end, parallaxElements, parallaxable, el, properties, property, value, transformStyle, numbers;\n\n        // Expose variables\n        self.frame = frame;\n        self.options = o;\n        self.parents = parents;\n        self.initialized = false;\n\n        /**\n         * (Re)Loading function.\n         *\n         * Populate arrays, set sizes, add spies, ...\n         *\n         * @return {Object}\n         */\n        function load() {\n            $parents = frameIsWindow ? $doc.find(parentSelector) : $frame.find(parentSelector);\n            // Reset parents\n            parents.length = 0;\n\n            isHorizontal = !!o.horizontal;\n\n            // Iterate through parents\n            $parents.each(parentEachHandler);\n\n            // Update scroll\n            scrollHandler();\n\n            if (o.performanceTrick) {\n                $freezer = frameIsWindow ? $doc : $frame;\n            }\n\n            // Trigger :load event\n            trigger('load');\n\n            return self;\n        }\n        self.reload = load;\n\n        /**\n         * Each parent handler\n         *\n         * @param {Int}   i         Parent index.\n         * @param {Node}  element   Parent DOM element.\n         *\n         * @return {Void}\n         */\n        var parentEachHandler = function(i, element) {\n            var $parent = $(element),\n                parentOptions = getInlineOptions($(element)),\n                parent = {};\n\n            parent.element = element,\n                parent.options = parentOptions,\n                parent.parallaxElements = [];\n\n            $parent.find(elementsSelector).each(function(pI, pElement) {\n                var parallaxElement = getInlineOptions($(pElement));\n                parallaxElement.element = pElement;\n\n                push.call(parent.parallaxElements, parallaxElement);\n            });\n\n            push.call(parents, parent);\n        }\n\n        /**\n         * Window resize handler.\n         *\n         * @return {Void}\n         */\n        function resizeHandler() {\n            if (resizeID) {\n                resizeID = clearTimeout(resizeID);\n            }\n\n            resizeID = setTimeout(function() {\n                self.reload();\n            });\n        };\n\n        /**\n         * Frame scrolling handler.\n         *\n         * @return {Void}\n         */\n        function scrollHandler() {\n            var l = parents.length;\n            if (o.performanceTrick && $freezer) {\n                clearTimeout(timer);\n\n                if (!containsPerformanceClass) {\n                    $freezer.addClass('scrollax-performance');\n                    containsPerformanceClass = true;\n                }\n\n                timer = setTimeout(function() {\n                    $freezer.removeClass('scrollax-performance');\n                    containsPerformanceClass = false;\n                }, 100);\n            }\n\n            if (!l) {\n                return;\n            }\n\n            // Get frame offset\n            offset = getOffset(frame);\n\n            for (var i = 0; i < l; i++) {\n                parent = parents[i];\n                pos = position(parent.element, frame);\n\n                if (pos[isHorizontal ? 'right' : 'bottom'] < 0 || pos[isHorizontal ? 'left' : 'top'] > offset[isHorizontal ? 'width' : 'height']) {\n                    continue;\n                }\n\n                parentOptions = parent.options;\n                parentOffset = parentOptions.offset || o.offset || 0;\n                start = pos[isHorizontal ? 'right' : 'bottom'];\n                end = pos[isHorizontal ? 'width' : 'height'];\n\n                // Calculate parent parallax ratio\n                ratio = (end - start + parentOffset) / end;\n\n                if (ratio < 0) {\n                    start = pos[isHorizontal ? 'left' : 'top'];\n                    end = offset[isHorizontal ? 'width' : 'height'];\n\n                    // Calculate negative parent parallax ratio\n                    ratio = -1 + (end - start + parentOffset) / end;\n                }\n\n                if (ratio > 1 || ratio < -1) {\n                    continue;\n                }\n\n                parallax(parent, ratio, isHorizontal);\n            }\n\n            // Trigger :scroll event\n            trigger('scroll', offset);\n        }\n        self.scroll = scrollHandler;\n\n        /**\n         * Parallax handler.\n         *\n         * @param {Int}    index    Parent object.\n         * @param {Object} offset   Scroll offset.\n         *\n         * @return {Void}\n         */\n        function parallax(parent, ratio) {\n            parallaxElements = parent.parallaxElements;\n            var l = parallaxElements.length;\n\n            if (!l) {\n                return;\n            }\n\n            for (var i = 0; i < l; i++) {\n                parallaxable = parallaxElements[i];\n                el = parallaxable.element;\n\n                // Set needed styles to parallaxable element\n                styleHandler(el, parallaxable, ratio);\n            }\n        }\n\n        /**\n         * Style handler for parallaxable element.\n         *\n         * @param {Node}   element        Parallaxable DOM element.\n         * @param {Object} parallaxable   Parallaxable options.\n         * @param {int}    ratio          Parallax ratio.\n         *\n         * @return {Int}  Parent     index, or -1 if not found.\n         */\n        function styleHandler(element, parallaxable, ratio) {\n            properties = parallaxable.properties || (isHorizontal ? { 'translateX': '100%' } : { 'translateY': '100%' });\n            transformStyle = \"\";\n\n            for (property in properties) {\n                value = properties[property];\n\n                if (typeof value === 'number') {\n                    value = value * ratio;\n                } else if (typeof value === 'string') {\n                    numbers = value.match(numberRegExp);\n                    value = value;\n\n                    for (i = 0, l = numbers.length; i < l; i++) {\n                        value = value.replace(numbers[i], parseFloat(numbers[i] * ratio));\n                    };\n                }\n\n                if ($.inArray(property, transforms) !== -1) {\n                    transformStyle += property + '(' + value + ')';\n                } else {\n                    element.style[property] = property === 'opacity' ? within(ratio < 0 ? 1 + value : 1 - value, 0, 1) : value;\n                }\n            }\n\n            if (transformStyle) {\n                element.style[transform] = gpuAcceleration + transformStyle;\n            }\n        }\n\n        /**\n         * Get the index of an parent in parents.\n         *\n         * @param {Mixed} parent     Parent DOM element.\n         *\n         * @return {Int}             index, or -1 if not found.\n         */\n        function getIndex(parent) {\n            return typeof parent !== 'undefined' ?\n                is_numeric(parent) ?\n                parent >= 0 && parent < parents.length ? parent : -1 :\n                $parents.index(parent) :\n                -1;\n        }\n        // Expose getIndex without lowering the compressibility of it,\n        // as it is used quite often throughout Scrollax.\n        self.getIndex = getIndex;\n\n        /**\n         * Trigger callbacks for event.\n         *\n         * @param  {String} name Event name.\n         * @param  {Mixed}  argX Arguments passed to callbacks.\n         *\n         * @return {Void}\n         */\n        function trigger(name, arg1) {\n            if (callbacks[name]) {\n                l = callbacks[name].length;\n                // Callbacks will be stored and executed from a temporary array to not\n                // break the execution queue when one of the callbacks unbinds itself.\n                tmpArray.length = 0;\n                for (i = 0; i < l; i++) {\n                    push.call(tmpArray, callbacks[name][i]);\n                }\n                // Execute the callbacks\n                for (i = 0; i < l; i++) {\n                    tmpArray[i].call(self, name, arg1);\n                }\n            }\n        }\n\n        /**\n         * Registers callbacks to be executed only once.\n         *\n         * @param  {Mixed} name  Event name, or callbacks map.\n         * @param  {Mixed} fn    Callback, or an array of callback functions.\n         *\n         * @return {Object}\n         */\n        self.one = function(name, fn) {\n            function proxy() {\n                fn.apply(self, arguments);\n                self.off(name, proxy);\n            }\n            self.on(name, proxy);\n\n            return self;\n        };\n\n        /**\n         * Registers callbacks.\n         *\n         * @param  {Mixed} name  Event name, or callbacks map.\n         * @param  {Mixed} fn    Callback, or an array of callback functions.\n         *\n         * @return {Object}\n         */\n        self.on = function(name, fn) {\n            // Callbacks map\n            if (typeof(name) === 'object') {\n                for (var key in name) {\n                    if (hasOwnProperty.call(name, key)) {\n                        self.on(key, name[key]);\n                    }\n                }\n                // Callback\n            } else if (typeof(fn) === 'function') {\n                var names = name.split(' ');\n                for (var n = 0, nl = names.length; n < nl; n++) {\n                    callbacks[names[n]] = callbacks[names[n]] || [];\n                    if (callbackIndex(names[n], fn) === -1) {\n                        push.call(callbacks[names[n]], fn);\n                    }\n                }\n                // Callbacks array\n            } else if (typeof(fn) === 'array') {\n                for (var f = 0, fl = fn.length; f < fl; f++) {\n                    self.on(name, fn[f]);\n                }\n            }\n\n            return self;\n        };\n\n        /**\n         * Remove one or all callbacks.\n         *\n         * @param  {String} name Event name.\n         * @param  {Mixed}  fn   Callback, or an array of callback functions. Omit to remove all callbacks.\n         *\n         * @return {Object}\n         */\n        self.off = function(name, fn) {\n            if (fn instanceof Array) {\n                for (var f = 0, fl = fn.length; f < fl; f++) {\n                    self.off(name, fn[f]);\n                }\n            } else {\n                var names = name.split(' ');\n                for (var n = 0, nl = names.length; n < nl; n++) {\n                    callbacks[names[n]] = callbacks[names[n]] || [];\n                    if (typeof(fn) === 'undefined') {\n                        callbacks[names[n]].length = 0;\n                    } else {\n                        var index = callbackIndex(names[n], fn);\n                        if (index !== -1) {\n                            splice.call(callbacks[names[n]], index, 1);\n                        }\n                    }\n                }\n            }\n\n            return self;\n        };\n\n        /**\n         * Returns callback array index.\n         *\n         * @param  {String}   name Event name.\n         * @param  {Function} fn   Function\n         *\n         * @return {Int} Callback array index, or -1 if isn't registered.\n         */\n        function callbackIndex(name, fn) {\n            for (var i = 0, l = callbacks[name].length; i < l; i++) {\n                if (callbacks[name][i] === fn) {\n                    return i;\n                }\n            }\n            return -1;\n        }\n\n        /**\n         * Updates a signle or multiple option values.\n         *\n         * @param {Mixed} name  Name of the option that should be updated, or object that will extend the options.\n         * @param {Mixed} value New option value.\n         *\n         * @return {Object}\n         */\n        self.set = function(name, value) {\n            if ($.isPlainObject(name)) {\n                $.extend(o, name);\n            } else if (hasOwnProperty.call(o, name)) {\n                o[name] = value;\n            }\n\n            // Reload\n            load();\n\n            return self;\n        };\n\n        /**\n         * Destroys instance and everything it created.\n         *\n         * @return {Object}\n         */\n        self.destroy = function() {\n            // Unbind all events\n            unbind(window, 'resize', resizeHandler);\n            unbind(frame, 'scroll', scrollHandler);\n\n            // Remove this instance from instances\n            $.each(instances, function(instance, i) {\n                if (instance && instance.frame === frame) {\n                    splice.call(Scrollax.instances, i, 1);\n                }\n            });\n\n            parents.length = 0;\n            self.initialized = false;\n\n            // Trigger :destroy event\n            trigger('destroy');\n\n            return self;\n        };\n\n        /**\n         * Initialize.\n         *\n         * @return {Object}\n         */\n        self.init = function() {\n            if (self.initialized) {\n                return;\n            }\n\n            // Register callbacks map\n            self.on(callbackMap);\n\n            load();\n\n            // Bind all events\n            bind(window, 'resize', resizeHandler);\n            bind(frame, 'scroll', scrollHandler);\n\n            // Add this instance to all instances\n            push.call(Scrollax.instances, self);\n\n            self.initialized = true;\n\n            // Trigger :initialized event\n            trigger('initialized');\n\n            return self;\n        };\n    };\n\n    Scrollax.instances = [];\n\n    /**\n     * Send warning message to the browser.\n     *\n     * @param {String} message\n     *\n     * @return {Void}\n     */\n    function warn(message) {\n        if (console && console.warn) {\n            console.warn(namespace + ': ' + message);\n        } else {\n            throw (namespace + ': ' + message);\n        }\n    }\n\n    /**\n     * Get Offset.\n     *\n     * @param {String} message\n     *\n     * @return {Void}\n     */\n    function getOffset(element) {\n        var isWin = !!('pageYOffset' in element);\n\n        return {\n            width: isWin ? (window.innerWidth ||\n                document.documentElement.clientWidth ||\n                document.body.clientWidth) : element.offsetWidth,\n            height: isWin ? (window.innerHeight ||\n                document.documentElement.clientHeight ||\n                document.body.clientHeight) : element.offsetHeight,\n            left: element[isWin ? 'pageXOffset' : 'scrollLeft'],\n            top: element[isWin ? 'pageYOffset' : 'scrollTop']\n        };\n    }\n\n    /**\n     * A JavaScript equivalent of PHP’s is_numeric.\n     *\n     * @param {Mixed} value\n     *\n     * @return {Boolean}\n     */\n    function is_numeric(value) {\n        return (typeof(value) === 'number' || typeof(value) === 'string') && value !== '' && !isNaN(value);\n    }\n\n    /**\n     * Make sure that number is within the limits.\n     *\n     * @param {Number} number\n     * @param {Number} min\n     * @param {Number} max\n     *\n     * @return {Number}\n     */\n    function within(number, min, max) {\n        return number < min ? min : number > max ? max : number;\n    }\n\n    /**\n     * Get element inline options.\n     *\n     * @param {Object}   $element    jQuery object with element.\n     *\n     * @return {Object}\n     */\n    function getInlineOptions($element) {\n        var data = $element.data(lownamespace.toLowerCase());\n        return data && eval(\"({\" + data + \"})\") || {};\n    }\n\n    /**\n     * Check whether value is a window object.\n     *\n     * Uses duck typing to determine window. Without IE8 all we need is:\n     *\n     *   var type = Object.prototype.toString.call(val);\n     *   return type === '[object global]' || type === '[object Window]' || type === '[object DOMWindow]';\n     *\n     * @param  {Mixed} val\n     * @return {Boolean}\n     */\n    function isWindow(val) {\n        /* jshint eqeqeq:false */\n        var doc, docWin;\n        return !!(\n            val &&\n            typeof val === 'object' &&\n            typeof val.window === 'object' &&\n            val.window == val &&\n            val.setTimeout &&\n            val.alert &&\n            (doc = val.document) &&\n            typeof doc === 'object' &&\n            (docWin = doc.defaultView || doc.parentWindow) &&\n            typeof docWin === 'object' &&\n            docWin == val\n        );\n    };\n\n    // Returns element's position object relative to document, window, or other elements.\n    (function() {\n        var k, doc, docEl, win, winTop, winLeft, box, relBox;\n        /**\n         * Poor man's shallow object extend;\n         *\n         * @param  {Object} a\n         * @param  {Object} b\n         * @return {Object}\n         */\n        function extend(a, b) {\n            for (k in b) a[k] = b[k];\n            return a;\n        }\n\n        /**\n         * Returns element's position object with `left`, `top`, `bottom`, `right`,\n         * `width`, and `height` properties indicating the position and dimensions\n         * of element on a page, or relative to other element.\n         *\n         * @param {Element} element\n         * @param {Element} [relativeTo] Defaults to `document.documentElement`.\n         *\n         * @return {Object|null}\n         */\n        position = function(element, relativeTo) {\n            doc = element.ownerDocument || element;\n            docEl = doc.documentElement;\n            win = isWindow(relativeTo) ? relativeTo : doc.defaultView || window;\n\n            // normalize arguments\n            relativeTo = !relativeTo || relativeTo === doc ? docEl : relativeTo;\n\n            winTop = (win.pageYOffset || docEl.scrollTop) - docEl.clientTop;\n            winLeft = (win.pageXOffset || docEl.scrollLeft) - docEl.clientLeft;\n            box = { top: 0, left: 0 };\n\n            if (element && element.getBoundingClientRect) {\n                // new object needed because DOMRect properties are read-only\n                box = extend({}, element.getBoundingClientRect());\n                // width & height don't exist in <IE9\n                box.width = box.right - box.left;\n                box.height = box.bottom - box.top;\n            } else {\n                return null;\n            }\n\n            // current box is already relative to window\n            if (relativeTo === win) return box;\n\n            // add window offsets, making the box relative to documentElement\n            box.top += winTop;\n            box.left += winLeft;\n            box.right += winLeft;\n            box.bottom += winTop;\n\n            // current box is already relative to documentElement\n            if (relativeTo === docEl) return box;\n\n            // subtract position of other element\n            relBox = position(relativeTo);\n            box.left -= relBox.left;\n            box.right -= relBox.left;\n            box.top -= relBox.top;\n            box.bottom -= relBox.top;\n\n            return box;\n        }\n    }());\n\n    // Event binding component with support for legacy browsers.\n    (function() {\n        /**\n         * Prevets default event action in IE8-.\n         */\n        function preventDefault() {\n            this.returnValue = false;\n        }\n\n        /**\n         * Stops event propagation in IE8-.\n         */\n        function stopPropagation() {\n            this.cancelBubble = true;\n        }\n\n        /**\n         * Bind `el` event `type` to `fn`.\n         *\n         * @param {Element}  el\n         * @param {String}   type\n         * @param {Function} fn\n         * @param {Boolean}  [capture]\n         *\n         * @return {Function} `fn`\n         */\n        bind = window.addEventListener ? function(el, type, fn, capture) {\n            el.addEventListener(type, fn, capture || false);\n            return fn;\n        } : function(el, type, fn) {\n            var fnid = type + fn;\n\n            el[fnid] = el[fnid] || function() {\n                var event = window.event;\n                event.target = event.srcElement;\n                event.preventDefault = preventDefault;\n                event.stopPropagation = stopPropagation;\n                fn.call(el, event);\n            };\n\n            el.attachEvent('on' + type, el[fnid]);\n            return fn;\n        };\n\n        /**\n         * Unbind `el` event `type`'s callback `fn`.\n         *\n         * @param {Element}  el\n         * @param {String}   type\n         * @param {Function} fn\n         * @param {Boolean}  [capture]\n         *\n         * @return {Function} `fn`\n         */\n        unbind = window.removeEventListener ? function(el, type, fn, capture) {\n            el.removeEventListener(type, fn, capture || false);\n            return fn;\n        } : function(el, type, fn) {\n            var fnid = type + fn;\n            el.detachEvent('on' + type, el[fnid]);\n\n            // clean up reference to handler function, but with a fallback\n            // because we can't delete window object properties\n            try {\n                delete el[fnid];\n            } catch (err) {\n                el[fnid] = undefined;\n            }\n\n            return fn;\n        };\n    }());\n\n    // Feature detects\n    (function() {\n        var prefixes = ['', 'webkit', 'moz', 'ms', 'o'];\n        var el = document.createElement('div');\n\n        function testProp(prop) {\n            for (var p = 0, pl = prefixes.length; p < pl; p++) {\n                var prefixedProp = prefixes[p] ? prefixes[p] + prop.charAt(0).toUpperCase() + prop.slice(1) : prop;\n                if (el.style[prefixedProp] != null) {\n                    return prefixedProp;\n                }\n            }\n        }\n\n        // Global support indicators\n        transform = testProp('transform');\n        gpuAcceleration = testProp('perspective') ? 'translateZ(0) ' : '';\n    }());\n\n    // Default options\n    Scrollax.defaults = {\n        horizontal: false, // Enable for horizontal scrolling.\n        offset: 0, // Target area offset from start (top in vert., left in hor.).\n        parentSelector: null, // Select only PARENTs that match this selector.\n        elementsSelector: null, // Select only PARALLAX_ELEMENTS that match this selector.\n        performanceTrick: false // Use this option to optimize your scroll performance. This option will freeze CSS Animations and pointer events during scrolling\n    };\n\n    // Expose the Scrollax\n    window.Scrollax = Scrollax;\n\n    // Extend jQuery\n    $.fn.Scrollax = function(options, callbackMap) {\n        var method, methodArgs;\n\n        // Attributes logic\n        if (!$.isPlainObject(options)) {\n            if (typeof options === 'string' || options === false) {\n                method = options === false ? 'destroy' : options;\n                methodArgs = slice.call(arguments, 1);\n            }\n            options = {};\n        }\n\n        // Apply to all elements\n        return this.each(function(i, element) {\n            // Call with prevention against multiple instantiations\n            var plugin = $.data(element, lownamespace);\n\n            if (!plugin && !method) {\n                // Create a new object if it doesn't exist yet\n                plugin = $.data(element, lownamespace, new Scrollax(element, options, callbackMap).init());\n            } else if (plugin && method) {\n                // Call method\n                if (plugin[method]) {\n                    plugin[method].apply(plugin, methodArgs);\n                }\n            }\n        });\n    };\n\n    $.Scrollax = function(options, callbackMap) {\n        $win.Scrollax(options, callbackMap);\n    };\n\n    var css = '.scrollax-performance, .scrollax-performance *, .scrollax-performance *:before, .scrollax-performance *:after { pointer-events: none !important; -webkit-animation-play-state: paused !important; animation-play-state: paused !important; };',\n        head = document.head || document.getElementsByTagName('head')[0],\n        style = document.createElement('style');\n\n    style.type = 'text/css';\n    if (style.styleSheet) {\n        style.styleSheet.cssText = css;\n    } else {\n        style.appendChild(document.createTextNode(css));\n    }\n\n    head.appendChild(style);\n\n    // AMD requirement\n    return Scrollax;\n}));\n"]}